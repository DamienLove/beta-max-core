## 2024-03-27 - Hardcoded Secrets in Frontend Config
**Vulnerability:** Found hardcoded Firebase API keys and configuration in `src/firebase.js`.
**Learning:** Even if keys are technically public (like some Firebase keys), hardcoding them sets a bad precedent and makes environment management (dev/staging/prod) impossible without code changes. It also risks exposing more sensitive keys if developers follow the same pattern.
**Prevention:** Use `import.meta.env` (Vite) or `process.env` (Node) for all configuration. Add `.env` to `.gitignore` immediately upon project creation. Provide `.env.example` for onboarding.

## 2024-05-22 - Insecure Firestore Rules (Public Access)
**Vulnerability:** Firestore rules were configured to allow public read/write access to everyone (`allow read, write: if request.time < ...`).
**Learning:** Default "Test Mode" rules provided by Firebase are often left unchanged, creating a massive security hole where anyone with the project ID can dump or delete the database.
**Prevention:** Always initialize Firestore with "Production Mode" (deny all) or immediately configure `request.auth != null` rules. Never rely on time-based rules for security.

## 2024-05-27 - Detached Firestore Rules & Permissive Defaults
**Vulnerability:** The project `betamax-portal` was using a local `firestore.rules` that allowed full read/write access to any authenticated user, ignoring the granular (but slightly insecure due to a TODO) rules defined in the root `firestore.rules`.
**Learning:** Monorepo structures or misplaced configuration files can lead to the "secure" version of a file being ignored in favor of a default, insecure one generated by CLI tools.
**Prevention:** Verify `firebase.json` configuration paths. Explicitly check the *content* of the active rules file against security requirements. Don't assume the file you see in the root is the one being deployed.

## 2025-02-24 - Root Configuration Drift (Insecure Deployment Risk)
**Vulnerability:** The root `firestore.rules` file contained permissive "TEMP" rules allowing any authenticated user to read all internal "mission" data, differing from the secure configuration in `betamax-portal/firestore.rules`.
**Learning:** In a repo where deployment might happen from the root, having a different (and insecure) configuration file at the root level creates a high risk of accidental security regression. Developers running `firebase deploy` from the root would unknowingly overwrite secure rules with insecure ones.
**Prevention:** In monorepos, ensure a single source of truth for infrastructure configuration or implement CI checks to enforce parity between configuration files. If multiple files must exist, they must be kept in sync.

## 2025-02-26 - Excessive Data Exposure in Firestore
**Vulnerability:** The `anomalies` collection allowed any authenticated user to read all documents (`allow read: if isSignedIn();`), exposing sensitive bug reports and logs to users who shouldn't see them.
**Learning:** Security rules must strictly adhere to the principle of least privilege. Granting broad read access to "simplify" development or assuming "security by obscurity" (that users won't query collections they don't see in the UI) is a critical flaw. Even if the UI doesn't list the data, the API does.
**Prevention:** Always scope read permissions to the specific owners or participants of the data (e.g., `reporterId` or `architectId`), mirroring the restrictions applied to write/update operations.

## 2025-02-27 - Insecure Prototype Defaults (Auth Bypass)
**Vulnerability:** The `PrototypeApp` was hardcoded to initialize the user state to an Admin user (`MOCK_USERS[0]`), effectively bypassing the authentication screen entirely for anyone visiting the app.
**Learning:** Developers often insert "convenience" backdoors in prototypes to speed up testing (e.g., auto-login). If these prototypes are deployed or the code is copied to production, they become critical vulnerabilities. Codebase "prototypes" should still respect the security boundary of the application logic.
**Prevention:** Always implement "Secure Defaults". Even in prototypes, default to a "logged out" or "safe" state. If bypasses are needed for dev efficiency, they must be behind explicit feature flags (e.g., environment variables) that are disabled by default.
