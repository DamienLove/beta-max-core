## 2024-03-27 - Hardcoded Secrets in Frontend Config
**Vulnerability:** Found hardcoded Firebase API keys and configuration in `src/firebase.js`.
**Learning:** Even if keys are technically public (like some Firebase keys), hardcoding them sets a bad precedent and makes environment management (dev/staging/prod) impossible without code changes. It also risks exposing more sensitive keys if developers follow the same pattern.
**Prevention:** Use `import.meta.env` (Vite) or `process.env` (Node) for all configuration. Add `.env` to `.gitignore` immediately upon project creation. Provide `.env.example` for onboarding.

## 2024-05-22 - Insecure Firestore Rules (Public Access)
**Vulnerability:** Firestore rules were configured to allow public read/write access to everyone (`allow read, write: if request.time < ...`).
**Learning:** Default "Test Mode" rules provided by Firebase are often left unchanged, creating a massive security hole where anyone with the project ID can dump or delete the database.
**Prevention:** Always initialize Firestore with "Production Mode" (deny all) or immediately configure `request.auth != null` rules. Never rely on time-based rules for security.

## 2024-05-27 - Detached Firestore Rules & Permissive Defaults
**Vulnerability:** The project `betamax-portal` was using a local `firestore.rules` that allowed full read/write access to any authenticated user, ignoring the granular (but slightly insecure due to a TODO) rules defined in the root `firestore.rules`.
**Learning:** Monorepo structures or misplaced configuration files can lead to the "secure" version of a file being ignored in favor of a default, insecure one generated by CLI tools.
**Prevention:** Verify `firebase.json` configuration paths. Explicitly check the *content* of the active rules file against security requirements. Don't assume the file you see in the root is the one being deployed.

## 2025-02-24 - Root Configuration Drift (Insecure Deployment Risk)
**Vulnerability:** The root `firestore.rules` file contained permissive "TEMP" rules allowing any authenticated user to read all internal "mission" data, differing from the secure configuration in `betamax-portal/firestore.rules`.
**Learning:** In a repo where deployment might happen from the root, having a different (and insecure) configuration file at the root level creates a high risk of accidental security regression. Developers running `firebase deploy` from the root would unknowingly overwrite secure rules with insecure ones.
**Prevention:** In monorepos, ensure a single source of truth for infrastructure configuration or implement CI checks to enforce parity between configuration files. If multiple files must exist, they must be kept in sync.

## 2025-02-26 - Excessive Data Exposure in Firestore
**Vulnerability:** The `anomalies` collection allowed any authenticated user to read all documents (`allow read: if isSignedIn();`), exposing sensitive bug reports and logs to users who shouldn't see them.
**Learning:** Security rules must strictly adhere to the principle of least privilege. Granting broad read access to "simplify" development or assuming "security by obscurity" (that users won't query collections they don't see in the UI) is a critical flaw. Even if the UI doesn't list the data, the API does.
**Prevention:** Always scope read permissions to the specific owners or participants of the data (e.g., `reporterId` or `architectId`), mirroring the restrictions applied to write/update operations.

## 2025-02-27 - Insecure Prototype Defaults (Auth Bypass)
**Vulnerability:** The `PrototypeApp` was hardcoded to initialize the user state to an Admin user (`MOCK_USERS[0]`), effectively bypassing the authentication screen entirely for anyone visiting the app.
**Learning:** Developers often insert "convenience" backdoors in prototypes to speed up testing (e.g., auto-login). If these prototypes are deployed or the code is copied to production, they become critical vulnerabilities. Codebase "prototypes" should still respect the security boundary of the application logic.
**Prevention:** Always implement "Secure Defaults". Even in prototypes, default to a "logged out" or "safe" state. If bypasses are needed for dev efficiency, they must be behind explicit feature flags (e.g., environment variables) that are disabled by default.

## 2026-01-23 - Unverified User ID on Creation
**Vulnerability:** `enrollments`, `anomalies`, and `external_betas` collections allowed any authenticated user to create documents with arbitrary user IDs (e.g. `userId`, `reporterId`), effectively allowing users to spoof actions on behalf of others.
**Learning:** It is a common mistake to assume that because a user is authenticated (`isSignedIn()`), they are trustworthy. Security rules must explicitly verify that the user is claiming resources for themselves, not just that they are logged in.
**Prevention:** Always validate that the user-ID field in the incoming document (`request.resource.data.userId`) matches the authenticated user (`request.auth.uid`) during creation.
## 2025-05-20 - Missing Owner Check on Create
**Vulnerability:** Firestore rules for `enrollments`, `anomalies`, and `external_betas` allowed any authenticated user to create documents without verifying that they were the owner (e.g., `userId` or `reporterId` matched `request.auth.uid`).
**Learning:** `allow create: if isSignedIn()` is insufficient for user-owned data. It prevents unauthenticated access but allows authenticated users to spoof others by creating documents with arbitrary user IDs.
**Prevention:** Always enforce `request.resource.data.userId == request.auth.uid` (or equivalent) in create rules.

## 2026-02-01 - Privilege Escalation via User Profile Updates
**Vulnerability:** The `users` collection allowed any authenticated user to write to their own document (`allow write: if isOwner(userId);`), which implicitly included the ability to change the `role` field (e.g., from 'tester' to 'developer'), leading to privilege escalation.
**Learning:** Generic `write` permissions are dangerous for user profiles where sensitive claims (like roles or credits) are stored alongside editable profile data (like names). Also, when splitting `write` into `create`/`update`, great care must be taken to handle missing fields in existing documents using `resource.data.get()` to avoid locking users out of updates.
**Prevention:** Split `write` into specific operations. Explicitly validate that sensitive fields are not present in the `request.resource.data` or match the existing value during updates. Use `.get()` with defaults to handle schema evolution safely.

## 2025-02-28 - Client-Side Mock Auth Bypass
**Vulnerability:** The prototype authentication logic verified only the existence of an email in a hardcoded list, completely ignoring the password field, allowing login with any password.
**Learning:** Mock authentication systems in prototypes often skip password verification for speed. However, this creates a false sense of security and a dangerous pattern that might be copied or relied upon. It also trains developers to treat authentication as a binary "exists/doesn't exist" check rather than a credential verification.
**Prevention:** Even in client-side prototypes, simulate proper authentication by hashing mock passwords and verifying them. This maintains the "shape" of secure code even if the implementation is mock-only.
